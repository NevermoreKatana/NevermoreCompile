# NevermoreCompile - Nevermpre Programming Language
[![Codacy Badge](https://app.codacy.com/project/badge/Grade/edf91b9620424cb9bd320449b735abe6)](https://app.codacy.com/gh/NevermoreKatana/NevermoreCompile/dashboard?utm_source=gh&utm_medium=referral&utm_content=&utm_campaign=Badge_grade)
[![Тесты](https://github.com/NevermoreKatana/NevermoreCompile/actions/workflows/python-app.yml/badge.svg)](https://github.com/NevermoreKatana/NevermoreCompile/actions/workflows/python-app.yml)

# Установка NEPL
## Клонирование репозитория
Первым шагом необходимо склонировать репозиторий NEPL GitHub. В нем содержится весь исходный код компилятора и веб части - веб часть можно удалить
```
git clone https://github.com/NevermoreKatana/NevermoreCompile.git
```

### Создание виртуальной среды и установка зависимостей
Если нет необходимости создавать виртуальную среду python venv, можете установить зависимости без её создания.

Создание виртуальной среды, .venv - можете заменить на своё название. Команда может поменяться в зависимости от того установлен просто python или python3.
```
python3 -m venv .venv
```
Активация виртуальной среды для Linux
```
source имя venv которую создали/bin/activate
```
### Установка зависимостей
```
pip install -r requirements.txt
```
### Так же для работы необходимо установить Clang утилиту!


# Старт работы с NEPL
### Быстрый старт
После установки в модуле compil будет файл input.txt. В нём вы можете начать писать свой код и для компиляции использовать команду ниже. После компиляции в папке compil/output_files появятся сгенерированные во время работы файлы, а в терминал выведется результат компиляции
```
make compile
```
###  Использование команды в терминале
Для компиляции можно использовать команду
```
python3 compil/compiler.py -f compil/input.txt -o compil/outpit_files
```
Именно эту команду исполняет make compile. Для того чтобы увидеть аргументы можно ввести в терминал
```
python3 compil/compiler.py -h
```
На выходе вы получите полное описание того что необходимо ввести. Аргумент -f - входной файл с исходным кодом. Аргумент -o - выходная директория, куда будут сохраняться все файлы во время исполнения программы.

# Переменные в NEPL
### Обычное создание переменной
Для создания переменной, первое что нужно указать - тип переменной int/double, после чего нужно написать имя переменной, оно может состоять из английских, русских букв + цифра, цифра должна обязательно быть в конце! После чего нужно поставить оператор присваивания = и указать чему равна ваша переменная

При присваивании переменная может принимать значение - любые математические действия, числа, другие переменные.

Пример
```
void main(){
    int x = 15;
    double y = 1.1;
    int x = x + x * x;
};
```
### Создание глобальных переменных
Глобальные переменные создаются с помощью оператора global. Важно указать global до начала входа в программу - функции main. После указания оператора global поставить двоеточие и перечислить переменные указывая их тип данных.

Пример
```
global: int:x double:y int:z;
void main(){
    ...
};
```
Важно, перед использованием глобальной переменной задать ей значение!

### Область видимости переменных
Переменные которые были созданы локально функции без указания оператора global будут видны только внутри этой функции.

Всё что глобально видно везде, всё что локально видно только внутри этой функции!

# Условные операторы
### Операторы сравнения
В NEPL есть только 4 оператора сравнения
```
== - равно
!= - неравно
> - больше
< - меньше
В условиях можно сравнивать
```
```
Целое число и целое число
Дробное число и Дробное число
Целое число и Дробное число
Дробное число и целое число 
Аналогично с переменными!
```
Создание условного оператора if
Для создания условного оператора if используется следующая конструкция

```
if условие{Действия};
```
Пример
```
void main(){
    if 1<2
        {
            print(1);
        };
    int x = 15;
    int z = 10;
    if x < z
        {
            print(1);
        };
};
```
### Создание условного оператора ifelse
Для создания условного оператора if используется следующая конструкция
```
if условие{Действия} else {Действия};
```
Пример
```
void main(){
    if 1<2{
        print(1);
    }else{
        print(2);
    };
    int x = 15;
    int y = 10;
    if x < y{
        print(1);
    }else{
        print(2);
    };
};
```
## Важно! Отступы при написании кода - не имеют значения!
Код написанный таким способом
```
void main(){
if 1<2{
print(1);
}else{
print(2);
};
int x = 15;
int y = 10;
if x < y{
print(1);
}else{
print(2);
};
};
```
Будет исполняться точно так же как код написанный с отступами
```
void main(){
    if 1<2{
        print(1);
    }else{
        print(2);
    };
    int x = 15;
    int y = 10;
    if x < y{
        print(1);
    }else{
        print(2);
    };
};
```

# Циклы
### Операторы сравнения
В NEPL есть только 4 оператора сравнения
```
== - равно
!= - неравно
> - больше
< - меньше
В циклах можно сравнивать
```
```
Целое число(переменная) и целое число(переменная)
Просто числа сравнивать нельзя в отличии от if/ifelse!
```
### Создание цикла while
Для создания цикла while используется следующая конструкция. Важно отметить, что левая часть в условии автоматически инкриминируется!
```
while (условие){Действия};
```
Пример
```
void main(){
    int x = 15;
    int y = 10;
    while (y < x){
        print(1);
    };
};
```
### Создание условного оператора dowhile
Для создания цикла dowhile используется следующая конструкция. Важно отметить, что левая часть в условии автоматически инкриминируется!
```
do{Действия}while(условие);
```
Пример
```
void main(){
    int x = 15;
    int y = 10;
    do{
        print(1);
    }while(x < y);
};
```
### Создание цикла for
Для создания цикла for используется следующая конструкция. В цикле for возможно поставить либо инкремент(++) либо декремент(--)
```
for (модификаця){Действия};
```
Пример
```
void main(){
    for (int i = 0; i<10; i++){
        print(1);
    };
};
```
### Важно! Отступы при написании кода - не имеют значения!
Код написанный таким способом
```
void main(){
int x = 15;
int y = 10;
do{
print(1);
}while(x < y);
};
```
Будет исполняться точно так же как код написанный с отступами
```
void main(){
    int x = 15;
    int y = 10;
    do{
        print(1);
    }while(x < y);
};
```
# Функции
В NEPL есть два вида функций - void(не возвращает значение) и int(возвращает значение - целое число)

Оба типа функций могут принимать аргументы

### Функция void main
Функция void main - является входом в программу, без её наличия ничего работать не будет. Она обязательно должна быть написана в начале программы. Если есть глобальные переменные, то пишутся сначала глобальные переменные.
```
void main(){
    ...
};
```
```
global: int:x;
void main(){
    ...
};
```
Функция main может принимать только тип void. Вызов этой функции происходит автоматически!

### Создание функции void
Для создания функции с типом void используется следующая конструкция. Выход из функции происходит автоматически после полного её исполнения. args* - неопределенное количество аргументов которые должна принимать функция при вызове.
```
void `name`(args*){Действия};
```
Пример
```
void main(){
    void test(int x, double y){
        ...
    };
};
```
Если функция не должна принимать аргументы скобки оставить пустыми!
# Создание функции int
Для создания функции с типом int используется следующая конструкция. args* - неопределенное количество аргументов которые должна принимать функция при вызове.
```
int `name`(args*){Действия};
```
Для выхода из функции нужно написать оператор `return` в нужном месте и через пробел указать одно значение для возврата с типом int32(целое число), это может быть как просто число так и переменная

Пример
```
void main(){
    int test(int x, double y){
        ...
    };
};
```
Если функция не должна принимать аргументы скобки оставить пустыми!
### Вызов функций
Для вызова функций используется следующая конструкция
```
`name`(args*)
```
```
int `var name` = `name`(args)
```
```
void main(){
    int test(int x, double y){
    };
    test(1,2);
    int x = test(1,2);
};
```
Вызов с созданием/присваиванием значением к переменной необходимо делать только, если функция возвращает значение
###  Важно! Отступы при написании кода - не имеют значения!
Код написанный таким способом
```
void main(){
int test(int x, double y){
};
test(1,2);
int x = test(1,2);
};
```
Будет исполняться точно так же как код написанный с отступами
```
void main(){
    int test(int x, double y){
    };
    test(1,2);
    int x = test(1,2);
};
```
# Примеры кода
## Пример 1
```
void main(){
  int x = 1;
  double y = 2.3;

  int result = 2 + 4 + 24/6*3 -24/24 + 31;
  print(result);
  int result = x + x * 2 * x/x*x*x;
  print(result);
  int result = x + 2 * 2 + x/1 + 24 * 6 /3;
  print(result);

  double result1 = y + y *2 / y*3 + y*y /y*8;
  print(result1);
  double result1 = 2 * y + 3.3 * y/y*3*y + 4*y/5;
  print(result1);

};
```
## Пример 2
```
void main(){
  # Создание переменной с типами int и double и их вывод
  int x = 111;
  double y = 22.2221;
  print(x);
  print(y);
  # Создание функции внутри которой создаются переменные с такими же именами 
  void test(){
    int x = 222;
    double y = 33.333;
    print(x);
    print(y);
  };
  # Создание функции в аргументах которой переменные с такими же именами
  void test1(int x, double y){
    print(x);
    print(y);
  };

  test()
  test1(x, y)

};
```
## Пример 3
```
global: int:j;
void main(){
  int j = 2;
  int x = 0;
  int y = 5;
  int z = 1;
  # Обычный вызов цикла 
  while(x < y){
    int z = z+z;
  };
  print(z);
  # Вызов цикла в функции void
  void loop(){
    int t = 0;
    int q = 5;
    while(t < q){
      int j = j+j;
    };
  };
  # Вызов цикла в функции int с аргументами
  int loop1(int x, int y){
    int result = 1;
    while (x < y){
      int result = result +result;
    };
    return result;
  };

  loop()
  print(j);
  int result = loop1(0, 10);
  print(result);

};
``` 
## Пример 4
```
global: int:j;
void main(){
  # Создание переменных для условий
  int j = 1;
  int x = 0;
  int y = 2;
  double d = 2.3;
  double z = 3.3;
  # Создание условий для тестов int&int, double&double, int&double, id&id etc
  if x < y{
    print(j);
  };

  if x>y{
    print(j);
  }
  else {
    print(22);
  };

  if d < z{
    print(j);
  };

  if d>z{
    print(j);
  }
  else {
    print(22);
  };

  if d!=z{
    print(j);
  };

  if d == z{
    print(j);
  }
  else{
    print(22);
  };

  if x!=z{
    print(j);
  };
  if x == z{
    print(j);
  }
  else {
    print(22);
  };

  if d > x{
    print(j);
  };
  if z > y{
    print(j);
  };

  void test(int x, int y, double d, double z){
        if x < y{
    print(j);
  };

  if x > y{
    print(j);
  }
  else {
    print(22);
  };

  if d < z{
    print(j);
  };

  if d > z{
    print(j);
  }
  else {
    print(22);
  };

  if d != z{
    print(j);
  };

  if d == z{
    print(j);
  }
  else{
    print(22);
  };

  if x != z{
    print(j);
  };
  if x == z{
    print(j);
  }
  else {
    print(22);
  };

  if d > x{
    print(j);
  };
  if z > y{
    print(j);
  };
  };
  test(1, 2, 2.2, 3.2)
};
```